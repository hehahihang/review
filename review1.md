## CS (메모리 구조)
### :arrow_forward: 프로그램이 운영체제로 부터 제공받는 메모리 영역 중, Stack영역과 Heap영역에 대해서 설명해주세요.

프로그램을 실행하기 위해서는 운영체제(OS)가 프로그램의 정보를 메모리에 로드(Load) 해야 한다.  
또한 프로그램이 실행되는 동안 CPU가 코드를 처리하기 위해서는 **메모리가 명령어와 데이터들 저장해야 한다**   
따라서, 프로그램을 실행하면 운영체제(OS)는 우리가 실행시킨 프로그램을 위해 메모리 공간을 할당해준다.  
할당되는 메모리 공간은 크게 **Code영역**, **Stack영역**, **Heap영역**, **Data영역**으로 나뉜다.  

##### 할당 시기 : 프로그램이 실행될 때마다  
##### 할당 장소 : 메인 메모리(RAM)  
##### 할당 용도 : 프로그램 실행시 필요한 메모리 공간(지역변수, 전역변수 등을 위해)할당  <br><br>

* Code 영역
  - 실행할 프로그램의 코드가 저장되는 영역, 텍스트 영역이라 부르기도 함
  - 프로그램이 시작하고 종료될 때 까지 메모리에 계속 남아있는다.

* Data 영역
  -  **전역 변수**와 **정적(static) 변수**가 할당되는 영역
  - 프로그램의 시작과 동시에 할당되고, 프로그램이 종료되어야 메모리에서 소멸됨 

* Stack 영역
  - 프로그램이 자동으로 사용하는 임시 메모리 영역이다.
  - 함수의 호출시 생성되는 **지역변수**와 **매개변수**가 저장되는 메모리 영역
  - Stack 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 종료되면 소멸
  - Stack 영역에 저장되는 함수의 호출 정보를 스택프레임(StackFrame)이라 한다.  
  - 이러한 StackFrame 덕분에 함수의 호출이 끝난 뒤, 해당 함수가 호출되기 이전 상태로 돌아갈 수 있습니다.
  - 스택영역은 메모리의 높은 주소에서 낮은 주소로 할당된다.  
 
* Heap 영역
  - 프로그래머가 **직접 공간을 할당, 해제하는 메모리 공간이다**  
  - C에서 malloc() 또는 Java에서 new 연산자를 통해 메모리를 할당하고, free() 또는 delete 연산자를 통해 메모리를 해제한다.  
  - 힙 영역은 선입선출(FIFO)로, 가장 먼저 들어온 데이터가 가장 먼저 나간다 (메모리 할당 순서와 관련)
  - 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.  

* OverFlow
  - 한정된 메모리 공간이 부족하여 메모리 안에 있는 데이터가 넘쳐 흐르는 현상
  - Heap은 메모리 위쪽 주소부터 할당되고, Stack은 메모리 아래쪽 주소부터 할당되기 때문에 각 영역이 상대 메모리 공간을 침범하는 경우 발생  
  - Stack이 Heap을 침범하면 **StackOverflow**, 반대의 경우 **HeapOverflow**라고 한다.    

## 자료구조
### :arrow_forward: Stack과 Queue를 구현 할때. Java의 Array와 List중 각각 어떤 것으로 구현하는 것이 좋을지 설명해주세요.
* 추가할 예정! 둘다 list 사용하는게 좋아보이는데 사이즈 따라서 다른거 같기도하고

## Java
### :arrow_forward: Java의 접근제어자 Protected는 어떤 경우에 사용하는지 설명해주세요.

* 접근 제어자
  - 클래스나 변수 메서드의 접근을 제어하기 위해 사용하는 예약어,
  - **private, protected, default, public** 4가지 존재
 
|접근 제어자|접근 범위|
|------|---|
|**private**|같은 클래스 내에서만 접근 가능|
|**protected**|같은 패키지이거나 다른 패키지이지만 상속 받은 클래스 접근 가능|
|**default**|같은 패키지 안에서만 접근 가능|
|**public**|같은 프로젝트 내부의 어떠한 곳에서도 접근 가능|


## Android
### :arrow_forward: Android의 4대 컴포넌트와 각각의 특징을 설명해주세요.

* 컴포넌트
  - 컴포넌트는 하나의 독립된 형태로 존재하여, 각 역할을 수행함  
  
|컴포넌트|설명|
|------|---|
|**액티비티(Activity)**|사용자 화면(UI)를 담당|
|**서비스(Service)**|화면에서 보이지 않지만 특정한 기능을 백그라운드에서 처리|
|**브로드캐스트 리시버(BroadCast Receiver)**|단말기에서 발생하는 다양한 이벤트, 정보를 처리|
|**Content Provider**|앱 사이의 데이터 공유를 위한 인터페이스 제공|

### :arrow_forward: 본인이 개발한 안드로이드 앱에서 사용한 컴포넌트를 설명해주세요.  
### :arrow_forward: Android 생명주기(LifeCycle)에 대해서 설명해주세요.
* Android 생명주기(Activity LifeCycle)란?
  - 액티비티가 생성되고 종료되기 까지의 상태(State)
  - 액티비티는 6개의 주요 Callback method를 제공하고, 액티비티의 상태가 변경할 때 각 Callback method를 호출
  - 앱이 멈추거나, 불가피하게 종료되거나, 다시 시작되거나 하는 상황에서 적절하게 처리를 하기 위함

|콜백 메소드|호출 시점|역할 및 특징|
|------|---|---|
|**onCreate()**|액티비티 생성시 호출|화면에 보이는 뷰들의 일반적인 상태 설정, 필수 구현 + 전체 LifeCycle 안에서 1번만 호출|
|**onStart()**|액티비티가 화면에 보이기 전에 바로 호출|네트워크 통신으로 데이터 수신 or 서비스, 리스너 등록 가능, onResume() 메서드를 호출| 
|**onResume()**|액티비티가 포그라운드에 보일때 호출|사용자와 상호작용, 일시 중지 상태에서 돌아올 때도 호출함|
|**onPause()**|액티비티가 화면에서 가려졌을(멈췄을) 때|액티비티를 일시 중지 시킴, 현재 포그라운드 액티비티에 필요없는 리소스 해제 가능|
|**onStop()**|액티비티가 화면에서 완전히 사라졌을 때 호출|onStop()의 경우 멀티윈도우 모드에서 UI관려 작업 진행 가능, 데이터를 DB에 저장|
|**onDestory()**|액티비티가 소멸되기 전 호출|액티비티가 finish()로 종료되거나, 구성 변경(기기 회전 or 멀티 윈도우 모드)의 경우 소멸|

## Git
### :arrow_forward: Git 명령어중 stash는 어떤 경우에 사용하는지 설명해주세요.  

### stash ###
  * **아직 마무리하지 않은 작업을 Stack에 잠시 저장할 수 있도록 하는 명령어이다**  
  * **완료되지 않은 commit 하지 않고 나중에 꺼내와 다시 마무리할 수 있다**  
  * git stash 명령어를 사용하면 워킹 디렉토리에서 수정한 파일들만 저장한다
  * stash란 아래에 해당하는 파일들을 보관해두는 장소이다.
    1. Modified 이면서 Tracked 상태인 파일
      - Tracked 상태인 파일을 이미 수정한 경우 (Tracked : 과거에 이미 commit하여 스냅샷에 넣어진 관리 대상 상태의 파일)  
    2. Staging Area에 있는 파일(Staged 상태인 파일)
      - git add 명령을 실행한 경우
      - Staged 상태로 만들려면 git add 명령을 실행해야 한다
      - git add는 파일을 새로 추적할때도 사용하고, 수정한 파일을 Staged 상태로 만들때도 사용한다.
  

## ETC
### Q3 : REST API 개념에 대해서 설명해주세요.
* REST API란?
  - REST를 기반으로 서비스 API를 구현한 것  
* REST란?
  - 웹 상에서 사용되는 리소스(자원)를 HTTP URI로 표현하고, HTTP Method(GET, POST, PUT, DELETE)로 해당 자원에 대한 CRUD를 사용하는 것을 의미한다.
  - REST는 네트워크 상에서 Client와 Server의 통신 방식 중 하나이다.  
* REST를 사용하는 이유?
  - Application의 복잡도가 증가하며 어떻게 분리하고 통합하여 관리하느냐가 중요해졌다.  
    이를 위해 웹의 장점을 최대한으로 활용하기 위해 사용하는 아키텍쳐 스타일
  - 애플리케이션의 분리 및 통합, 다양한 클라이언트의 등장에 대응
  - 다양한 브라우저와 모바일기기(Android, iOS) 에서도 통신할 수 있어야하기 때문  
* REST의 장단점
  - 장점
    1. HTTP 프로토콜을 사용하므로 REST API를 위한 별도 인프라 구축 X
    2. HTTP 프로토콜을 따르는 모든 플랫폼에서 사용 가능
    3. REST API가 의도하는 바를 명확히 나타내므로 상태, 명령을 쉽게 파악할 수 있음
    4. 서버와 클라이언트의 역할을 명확하게 분리
  - 단점
    1. 표준이 존재하지 않음
    2. 사용할 수 있는 Method가 4가지 밖에 없다.
* REST의 특징  
  1. **Client - Server 구조** 
    - 자원을 가진 쪽 = Server, 자원을 요청하는 쪽 = Client
      - Rest Server : API를 제공하고 비즈니스 로직 처리 및 연산 담당
      - Client : 사용자 인증, context(로그인 정보, 세션) 등을 관리하고 책임진다.
    - 서로간의 의존성이 줄어듬<br><br>
  2. **Uniform Interface**  
    - URI로 지정한 리소스와 HTTP 표준에 따라 브라우저, 안드로이드, iOS 등 특정 언어나 기술에 제약 없이 모든 플랫폼에서 사용 가능<br><br>
  3. **Stateless(무상태성)** 
    - HTTP는 stateless 프로토콜 이고, REST 역시 stateless이다. 
    - Client의 Context를 서버에 따로 저장하지 않음 -> 세션, 쿠키 등의 정보를 신경쓰지 않아도 되서, 구현이 단순해진다.
    - 서버는 Client의 요청(request)을 별개로 인식하여 처리한다.
      - 각 API서버는 Client의 요청만을 처리한다.
      - 요청간의 연관성이 없어야한다.
      - 서버의 request 처리 방식에 일관성을 부여하여 부담을 줄임 -> 서비스의 자유도가 높아짐<br><br>
  4. **Cacheable(캐시 처리 가능)**  
    - HTTP 프로토콜을 그대로 사용하므로 기존의 웹 인프라를 사용
    - 대량의 요청을 효율적으로 사용하기 위한 캐시가 요구된다.
    - 캐시를 사용하여 응답시간이 빨라지고 Rest Server의 트랜잭션이 발생하지 않음 -> 전체 응답시간, 성능, 서버 자원 이용률 향상
    - 캐싱 구현은 Last-Modified 태그나 E-tag를 사용하여 가능<br><br>
  5. **Layerd System(계층화)**  
    - API서버는 순수 비즈니스 로직만을 수행
    - 앞단에 사용자 인증, 로드밸런싱, 암호화, 보안(SSL) 등을 추가하여 사용이 가능 -> 구조상 유연성 증가
    - Proxy 사용 가능, 더 나아가서는 API gateway 등을 활용하여 Micro Service Architecture로도 구현이 가능<br><br>
  6. **Self-descriptiveness (자체 표현 구조)**  
    - HTTP Method(GET,POST,PUT,DELETE)+ URI 로 이루어져있다.
    - Json, XML을 통해 메시지를 전달하고, REST API만을 보고 행위를 쉽게 이해할 수 있다.<br><br>
